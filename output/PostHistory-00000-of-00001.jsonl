{"PostId": "3758880", "CreationDate": "2020-11-30T10:29:35.070", "Text": "> **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.\r\n>\r\n> Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]\r\n\r\nSource: [Formatting byte size to human readable format | Programming.Guide][2]\r\n\r\n# SI (1 k = 1,000)\r\n\r\n    public static String humanReadableByteCountSI(long bytes) {\r\n        if (-1000 < bytes && bytes < 1000) {\r\n            return bytes + \" B\";\r\n        }\r\n        CharacterIterator ci = new StringCharacterIterator(\"kMGTPE\");\r\n        while (bytes <= -999_950 || bytes >= 999_950) {\r\n            bytes /= 1000;\r\n            ci.next();\r\n        }\r\n        return String.format(\"%.1f %cB\", bytes / 1000.0, ci.current());\r\n    }\r\n\r\n\r\n# Binary (1 Ki = 1,024)\r\n\r\n    public static String humanReadableByteCountBin(long bytes) {\r\n        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);\r\n        if (absB < 1024) {\r\n            return bytes + \" B\";\r\n        }\r\n        long value = absB;\r\n        CharacterIterator ci = new StringCharacterIterator(\"KMGTPE\");\r\n        for (int i = 40; i >= 0 && absB > 0xfffccccccccccccL >> i; i -= 10) {\r\n            value >>= 10;\r\n            ci.next();\r\n        }\r\n        value *= Long.signum(bytes);\r\n        return String.format(\"%.1f %ciB\", value / 1024.0, ci.current());\r\n    }\r\n\r\n# Example output:\r\n\r\n                                  SI     BINARY\r\n\r\n                       0:        0 B        0 B\r\n                      27:       27 B       27 B\r\n                     999:      999 B      999 B\r\n                    1000:     1.0 kB     1000 B\r\n                    1023:     1.0 kB     1023 B\r\n                    1024:     1.0 kB    1.0 KiB\r\n                    1728:     1.7 kB    1.7 KiB\r\n                  110592:   110.6 kB  108.0 KiB\r\n                 7077888:     7.1 MB    6.8 MiB\r\n               452984832:   453.0 MB  432.0 MiB\r\n             28991029248:    29.0 GB   27.0 GiB\r\n           1855425871872:     1.9 TB    1.7 TiB\r\n     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)\r\n\r\n  [1]: https://programming.guide/worlds-most-copied-so-snippet.html\r\n  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html\r\n"}
{"PostId": "9875710", "CreationDate": "2012-03-26T17:39:49.437", "Text": "I have a nice jQuery Extension perfect for this type of thing at this gist:\r\n\r\n> https://gist.github.com/2206057\r\n\r\nTo use it just do something like:\r\n\r\n    $(\"#eleID\").cursor(); // will return current cursor state for that element\r\n    $(\"#eleID\").cursor(\"pointer\"); // will change ele cursor to whatever is \"\"\r\n    $(\"#eleID\").cursor(\"clear\"); // will change ele cursor to default\r\n    $(\"#eleID\").cursor(\"ishover\"); // will return boolean of if mouse is over element or not\r\n    $(\"#eleID\").cursor(\"position\"); // will return cursor's current position in \"relation\" to element\r\n\r\nalso \r\n\r\n    $.cursor(\"wait\") // will change document cursor to whatever is \"\"\r\n    $.cursor($(\"#eleID\"), \"wait\"); // same as $(\"#eleID\").cursor(\"wait\");\r\n    $.cursor(\"position\") // will return current cursor position\r\n\r\nshould also mention, if you submit multiple elements like `$(\"#eleID1, .elementsWiththisClass\")` for \"position\" and \"isHover\" then it will return an `Array` containing objects like:\r\n\r\n    var poses = $(\"#eleID1, .elementsWiththisClass\").cursor(\"position\") //  will equal\r\n    poses[0] = {\r\n        ele: e.fn.e.init[1], // the jquery element\r\n        x: XXX, //  where XXX is the cursors current position in relation to element\r\n        y: XXX\r\n    }\r\n    poses[1] = { // ...and so on and so forth for each element"}
{"PostId": "326440", "CreationDate": "2020-09-28T15:31:38.653", "Text": "Read all text from a file\r\n-------------------------\r\nJava 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:\r\n\r\n    String content = Files.readString(path, StandardCharsets.US_ASCII);\r\n\r\nFor versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:\r\n\r\n    static String readFile(String path, Charset encoding)\r\n      throws IOException\r\n    {\r\n      byte[] encoded = Files.readAllBytes(Paths.get(path));\r\n      return new String(encoded, encoding);\r\n    }\r\n\r\nRead lines of text from a file\r\n------------------------------\r\n\r\nJava 7 added a [convenience method to read a file as lines of text,][2] represented as a `List<String>`. This approach is \"lossy\" because the line separators are stripped from the end of each line.\r\n\r\n    List<String> lines = Files.readAllLines(Paths.get(path), encoding);\r\n\r\nJava 8 added the [`Files.lines()`][3] method to produce a `Stream<String>`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.\r\n\r\n    try (Stream<String> lines = Files.lines(path, encoding)) {\r\n      lines.forEach(System.out::println);\r\n    }\r\n\r\nThis `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.\r\n\r\nIf you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.\r\n\r\nMemory utilization\r\n------------------\r\n\r\nThe first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.\r\n\r\nThe second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.\r\n\r\nFor reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, \"large\" depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream<String>` is one way to do this, if your input \"records\" happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)\r\n\r\nCharacter encoding\r\n------------------\r\n\r\nOne thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.\r\n\r\nThe [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:\r\n\r\n    String content = readFile(\"test.txt\", StandardCharsets.UTF_8);\r\n\r\nThe platform default is available from [the `Charset` class][8] itself:\r\n\r\n    String content = readFile(\"test.txt\", Charset.defaultCharset());\r\n\r\n---\r\nNote: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the \"edited\" link on this answer.\r\n\r\n\r\n  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)\r\n  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29\r\n  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-\r\n  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html\r\n  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--\r\n  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--\r\n  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html\r\n  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29\r\n"}