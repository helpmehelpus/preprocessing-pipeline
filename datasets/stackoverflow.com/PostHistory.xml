<?xml version="1.0" encoding="utf-8"?>
<posthistory>
  <row Id="7874570" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1658830c-b8e9-46cb-8797-c73152caec26" CreationDate="2010-09-21T10:47:31.883" UserId="276052" Comment="added 193 characters in body; added 42 characters in body; added 19 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;;&#xD;&#xA;        prefix = prefix.charAt(power-1) + (si ? &quot;B&quot; : &quot;iB&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="22587012" PostHistoryTypeId="5" PostId="9875710" RevisionGUID="52a2dc0a-5d0b-4c6b-ad53-40a9b928ad86" CreationDate="2012-03-26T17:39:49.437" UserId="900807" Comment="added 422 characters in body" Text="I have a nice jQuery Extension perfect for this type of thing at this gist:&#xD;&#xA;&#xD;&#xA;&gt; https://gist.github.com/2206057&#xD;&#xA;&#xD;&#xA;To use it just do something like:&#xD;&#xA;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(); // will return current cursor state for that element&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;pointer&quot;); // will change ele cursor to whatever is &quot;&quot;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;clear&quot;); // will change ele cursor to default&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;ishover&quot;); // will return boolean of if mouse is over element or not&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;position&quot;); // will return cursor's current position in &quot;relation&quot; to element&#xD;&#xA;&#xD;&#xA;also &#xD;&#xA;&#xD;&#xA;    $.cursor(&quot;wait&quot;) // will change document cursor to whatever is &quot;&quot;&#xD;&#xA;    $.cursor($(&quot;#eleID&quot;), &quot;wait&quot;); // same as $(&quot;#eleID&quot;).cursor(&quot;wait&quot;);&#xD;&#xA;    $.cursor(&quot;position&quot;) // will return current cursor position&#xD;&#xA;&#xD;&#xA;should also mention, if you submit multiple elements like `$(&quot;#eleID1, .elementsWiththisClass&quot;)` for &quot;position&quot; and &quot;isHover&quot; then it will return an `Array` containing objects like:&#xD;&#xA;&#xD;&#xA;    var poses = $(&quot;#eleID1, .elementsWiththisClass&quot;).cursor(&quot;position&quot;) //  will equal&#xD;&#xA;    poses[0] = {&#xD;&#xA;        ele: e.fn.e.init[1], // the jquery element&#xD;&#xA;        x: XXX, //  where XXX is the cursors current position in relation to element&#xD;&#xA;        y: XXX&#xD;&#xA;    }&#xD;&#xA;    poses[1] = { // ...and so on and so forth for each element" ContentLicense="CC BY-SA 3.0" />
  <row Id="7873162" PostHistoryTypeId="2" PostId="3758880" RevisionGUID="038858fc-3127-4011-be25-d8e8e74a7662" CreationDate="2010-09-21T09:22:21.483" UserId="276052" Text="Here is my go at it:&#xD;&#xA;&#xD;&#xA;    private static String[] prefix = new String[] {&quot;&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;};&#xD;&#xA;    &#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        if (bytes == 0) return &quot;0 B&quot;;&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = prefix[(int) power] + (si &amp;&amp; power &gt; 0 ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        String format = power == 0 ? &quot;%.0f %s&quot; : &quot;%.1f %s&quot;;&#xD;&#xA;        return String.format(format, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;The following lines:&#xD;&#xA;&#xD;&#xA;    for (long i = 0; i &lt; 10000000000000L; i = i == 0 ? 3 : i * 5)&#xD;&#xA;        System.out.printf(&quot;%14d: %10s %10s%n&quot;, i,&#xD;&#xA;                humanByteCount(i, true), humanByteCount(i, false));&#xD;&#xA;&#xD;&#xA;Prints&#xD;&#xA;&#xD;&#xA;                 0:        0 B        0 B&#xD;&#xA;                 3:        3 B        3 B&#xD;&#xA;                15:       15 B       15 B&#xD;&#xA;                75:       75 B       75 B&#xD;&#xA;               375:      375 B      375 B&#xD;&#xA;              1875:    1.9 KiB     1.8 KB&#xD;&#xA;              9375:    9.4 KiB     9.2 KB&#xD;&#xA;             46875:   46.9 KiB    45.8 KB&#xD;&#xA;            234375:  234.4 KiB   228.9 KB&#xD;&#xA;           1171875:    1.2 MiB     1.1 MB&#xD;&#xA;           5859375:    5.9 MiB     5.6 MB&#xD;&#xA;          29296875:   29.3 MiB    27.9 MB&#xD;&#xA;         146484375:  146.5 MiB   139.7 MB&#xD;&#xA;         732421875:  732.4 MiB   698.5 MB&#xD;&#xA;        3662109375:    3.7 GiB     3.4 GB&#xD;&#xA;       18310546875:   18.3 GiB    17.1 GB&#xD;&#xA;       91552734375:   91.6 GiB    85.3 GB&#xD;&#xA;      457763671875:  457.8 GiB   426.3 GB&#xD;&#xA;     2288818359375:    2.3 TiB     2.1 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873319" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="be00e77b-fbda-4803-a59e-cc202db1b43c" CreationDate="2010-09-21T09:31:09.437" UserId="276052" Comment="deleted 206 characters in body" Text="Here is my go at it:&#xD;&#xA;&#xD;&#xA;    private static String[] prefix = new String[] {&quot;&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;};&#xD;&#xA;    &#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        if (bytes == 0) return &quot;0 B&quot;;&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = prefix[(int) power] + (si &amp;&amp; power &gt; 0 ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        String format = power == 0 ? &quot;%.0f %s&quot; : &quot;%.1f %s&quot;;&#xD;&#xA;        return String.format(format, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                 0:        0 B        0 B&#xD;&#xA;                 3:        3 B        3 B&#xD;&#xA;                15:       15 B       15 B&#xD;&#xA;                75:       75 B       75 B&#xD;&#xA;               375:      375 B      375 B&#xD;&#xA;              1875:    1.9 KiB     1.8 KB&#xD;&#xA;              9375:    9.4 KiB     9.2 KB&#xD;&#xA;             46875:   46.9 KiB    45.8 KB&#xD;&#xA;            234375:  234.4 KiB   228.9 KB&#xD;&#xA;           1171875:    1.2 MiB     1.1 MB&#xD;&#xA;           5859375:    5.9 MiB     5.6 MB&#xD;&#xA;          29296875:   29.3 MiB    27.9 MB&#xD;&#xA;         146484375:  146.5 MiB   139.7 MB&#xD;&#xA;         732421875:  732.4 MiB   698.5 MB&#xD;&#xA;        3662109375:    3.7 GiB     3.4 GB&#xD;&#xA;       18310546875:   18.3 GiB    17.1 GB&#xD;&#xA;       91552734375:   91.6 GiB    85.3 GB&#xD;&#xA;      457763671875:  457.8 GiB   426.3 GB&#xD;&#xA;     2288818359375:    2.3 TiB     2.1 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873489" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1324adaa-9d8d-4f5c-8130-1dd4676ae1d4" CreationDate="2010-09-21T09:42:57.160" UserId="276052" Comment="deleted 338 characters in body; deleted 79 characters in body; added 41 characters in body" Text="Here is my go at it (handles both si units and binary units):&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = &quot;KMGTPE&quot;.charAt((int) power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                   1:        1 B        1 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873581" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1b2eebee-64f6-4565-b6cf-6ea41a153bd8" CreationDate="2010-09-21T09:49:12.813" UserId="276052" Comment="deleted 26 characters in body; added 4 characters in body; added 8 characters in body; added 13 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = &quot;KMGTPE&quot;.charAt(power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                   1:        1 B        1 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="22585938" PostHistoryTypeId="5" PostId="9875710" RevisionGUID="1cb680a0-3cf0-433f-942d-467b03fc9a64" CreationDate="2012-03-26T17:09:08.107" UserId="900807" Comment="added 721 characters in body" Text="I have a nice jQuery Extension perfect for this type of thing at this gist:&#xD;&#xA;&#xD;&#xA;&gt; https://gist.github.com/2206057&#xD;&#xA;&#xD;&#xA;To use it just do something like:&#xD;&#xA;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(); // will return current cursor state for that element&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;pointer&quot;); // will change ele cursor to whatever is &quot;&quot;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;clear&quot;); // will change ele cursor to default&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;ishover&quot;); // will return boolean of if mouse is over element or not&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;position&quot;); // will return current cursor position in &quot;relation&quot; to element&#xD;&#xA;&#xD;&#xA;also &#xD;&#xA;&#xD;&#xA;    $.cursor(&quot;wait&quot;) // will change document cursor to whatever is &quot;&quot;&#xD;&#xA;    $.cursor($(&quot;#eleID&quot;), &quot;wait&quot;); // same as $(&quot;#eleID&quot;).cursor(&quot;wait&quot;);&#xD;&#xA;    $.cursor(&quot;position&quot;) // will return current cursor position" ContentLicense="CC BY-SA 3.0" />
  <row Id="7874248" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="800ccb7a-67f4-467d-a69a-8b9ab7972e41" CreationDate="2010-09-21T10:27:59.107" UserId="276052" Comment="deleted 45 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = &quot;KMGTPE&quot;.charAt(power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7874704" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="d00ea2b0-2bcb-4eb9-aa15-41d989f40ff1" CreationDate="2010-09-21T10:55:46.207" UserId="276052" Comment="deleted 39 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        return String.format(&quot;%.1f %s%s&quot;, bytes / Math.pow(unit, power),&#xD;&#xA;                (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(power-1), si ? &quot;B&quot; : &quot;iB&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="200451414" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ba112991-749b-490b-8021-ea5c43ab192e" CreationDate="2019-06-26T21:51:28.527" UserId="3474" Comment="added 358 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 4.0" />
  <row Id="7875126" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="86947e50-9558-4cef-854e-542d31a6c50e" CreationDate="2010-09-21T11:22:55.253" UserId="276052" Comment="added 2 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="15577610" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="60eb1817-04bd-47ca-a93a-d49c13fbe9d4" CreationDate="2011-08-17T14:59:59.883" UserId="276052" Comment="edited body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 kB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
  <row Id="24534909" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="56de0e8d-0f69-4030-ab0f-92bd315394aa" CreationDate="2012-05-17T18:59:28.427" UserId="157882" Comment="Fixed typo" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
  <row Id="228647569" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="4a06b7d5-9422-4698-9780-387e54d95f07" CreationDate="2020-08-12T18:34:38.667" UserId="63550" Comment="Active reading." Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide][2]&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;  [1]: https://programming.guide/worlds-most-copied-so-snippet.html&#xD;&#xA;  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="130380462" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="4eaf6394-79cb-41c2-b209-601bace34bfc" CreationDate="2016-10-29T03:58:01.857" UserId="276052" Comment="added 161 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Related article: [Java: Formatting byte size to human readable format](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)" ContentLicense="CC BY-SA 3.0" />
  <row Id="210418581" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1510319a-551c-4ea1-bb72-9e67122bf2ba" CreationDate="2019-12-02T23:57:39.337" UserId="276052" Comment="added 1136 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        return bytes &lt; 1000L ? bytes + &quot; B&quot;&#xD;&#xA;                : bytes &lt; 999_950L ? String.format(&quot;%.1f kB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f MB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f GB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f TB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f PB&quot;, bytes / 1e3)&#xD;&#xA;                : String.format(&quot;%.1f EB&quot;, bytes / 1e6);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        return bytes &lt; 1024L ? bytes + &quot; B&quot;&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 40 ? String.format(&quot;%.1f KiB&quot;, bytes / 0x1p10)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 30 ? String.format(&quot;%.1f MiB&quot;, bytes / 0x1p20)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 20 ? String.format(&quot;%.1f GiB&quot;, bytes / 0x1p30)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 10 ? String.format(&quot;%.1f TiB&quot;, bytes / 0x1p40)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL ? String.format(&quot;%.1f PiB&quot;, (bytes &gt;&gt; 10) / 0x1p40)&#xD;&#xA;                : String.format(&quot;%.1f EiB&quot;, (bytes &gt;&gt; 20) / 0x1p40);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="210660032" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="f726a5eb-c96b-4613-ae53-f1e4cf3cf3bb" CreationDate="2019-12-06T05:24:51.067" UserId="276052" Comment="added 163 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        String s = bytes &lt; 0 ? &quot;-&quot; : &quot;&quot;;&#xD;&#xA;        long b = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        return b &lt; 1000L ? bytes + &quot; B&quot;&#xD;&#xA;                : b &lt; 999_950L ? String.format(&quot;%s%.1f kB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f MB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f GB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f TB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f PB&quot;, s, b / 1e3)&#xD;&#xA;                : String.format(&quot;%s%.1f EB&quot;, s, b / 1e6);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long b = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        return b &lt; 1024L ? bytes + &quot; B&quot;&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 40 ? String.format(&quot;%.1f KiB&quot;, bytes / 0x1p10)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 30 ? String.format(&quot;%.1f MiB&quot;, bytes / 0x1p20)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 20 ? String.format(&quot;%.1f GiB&quot;, bytes / 0x1p30)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 10 ? String.format(&quot;%.1f TiB&quot;, bytes / 0x1p40)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL ? String.format(&quot;%.1f PiB&quot;, (bytes &gt;&gt; 10) / 0x1p40)&#xD;&#xA;                : String.format(&quot;%.1f EiB&quot;, (bytes &gt;&gt; 20) / 0x1p40);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="217505446" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="fc80a938-014a-4b2d-a71c-ee168ea617c1" CreationDate="2020-03-23T15:00:26.887" UserId="276052" Comment="deleted 420 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="235940485" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="59426900-524d-4bf2-afbe-e05ac2dd6e56" CreationDate="2020-11-30T10:29:35.070" UserId="648265" Comment="fix designation to correspond to what the code produces" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide][2]&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 Ki = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;  [1]: https://programming.guide/worlds-most-copied-so-snippet.html&#xD;&#xA;  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="22583841" PostHistoryTypeId="2" PostId="9875710" RevisionGUID="b77c0329-4369-4ae7-9947-72738e2c02e7" CreationDate="2012-03-26T16:11:16.270" UserId="900807" Text="&lt;script src=&quot;https://gist.github.com/2206057.js?file=jqExtCursor.js&quot;&gt;&lt;/script&gt;" ContentLicense="CC BY-SA 3.0" />
  <row Id="167328771" PostHistoryTypeId="5" PostId="326440" RevisionGUID="028e71c4-b697-4770-910f-97d6b3bd9036" CreationDate="2018-02-20T22:51:08.997" UserId="3474" Comment="added 622 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;In Java 8, `BufferedReader` added a new method, [`lines()`][2] to produce a `Stream&lt;String&gt;`. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (BufferedReader r = Files.newBufferedReader(path, encoding)) {&#xD;&#xA;      r.lines().forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;There is also a `Files.lines()` method which does something very similar, returning the `Stream&lt;String&gt;` directly. But I don't like it. The `Stream` needs a `close()` call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. So your code would look very similar, like this:&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The difference is that you have a `Stream` assigned to a variable, and I try avoid that as a practice so that I don't accidentally try to invoke the stream twice.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][4] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][5] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [5]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="22583844" PostHistoryTypeId="12" PostId="9875710" RevisionGUID="b6403345-559b-44c5-9daa-253e63fbfbfe" CreationDate="2012-03-26T16:11:20.420" UserId="900807" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:900807,&quot;DisplayName&quot;:&quot;SpYk3HH&quot;}]}" />
  <row Id="22585948" PostHistoryTypeId="13" PostId="9875710" RevisionGUID="e20f5cce-70bc-4815-873d-8f62df4893eb" CreationDate="2012-03-26T17:09:19.963" UserId="900807" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:900807,&quot;DisplayName&quot;:&quot;SpYk3HH&quot;}]}" />
  <row Id="522158" PostHistoryTypeId="2" PostId="326440" RevisionGUID="4320894b-887d-49b9-b4f9-6fffbdd5c762" CreationDate="2008-11-28T18:56:13.693" UserId="3474" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = new .getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="522159" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ece84de0-3535-47ac-be79-b84b0a413183" CreationDate="2008-11-28T19:05:55.017" UserId="3474" Comment="Fix a typo in code." Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="522160" PostHistoryTypeId="5" PostId="326440" RevisionGUID="185326f5-11c1-41c6-a14d-b2f98f6a29fb" CreationDate="2008-11-28T19:13:16.747" UserId="3474" Comment="Fix another part of the same typo." Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="3890740" PostHistoryTypeId="5" PostId="326440" RevisionGUID="079c73bd-640b-49db-a9e3-b089d3ffe907" CreationDate="2009-12-21T03:52:07.540" UserId="3474" Comment="edited body" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return Charset.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="40278052" PostHistoryTypeId="5" PostId="326440" RevisionGUID="0cbeee87-efcd-47f6-b879-f10ba850dedb" CreationDate="2013-05-07T18:58:22.013" UserId="3474" Comment="added 558 characters in body" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return Charset.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;In Java 7, [a utility method has been added to read all &quot;lines&quot; from a file,][1] as a `List&lt;String&gt;`. This isn't exactly the same thing; some information is lost because the actual line terminators are discarded. It is, however, a robust and convenient implementation of an extremely common use case:&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = &#xD;&#xA;      Files.readAllLines(Paths.get(&quot;smallfile.txt&quot;), StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="40414907" PostHistoryTypeId="5" PostId="326440" RevisionGUID="667dea6c-5c31-4709-aaf6-ddb652cdce10" CreationDate="2013-05-10T07:08:42.820" UserId="3474" Comment="added 403 characters in body" Text="Here's a compact, robust idiom for Java 7, wrapped up in method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This method can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][1] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][2] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="40486052" PostHistoryTypeId="5" PostId="326440" RevisionGUID="cbb5f92a-9c7b-499b-b582-568b1afeed93" CreationDate="2013-05-11T18:43:04.003" UserId="3474" Comment="added 10 characters in body" Text="Read text from a file&#xD;&#xA;---------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;This method can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][1] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][2] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="59731823" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5da3e505-d708-4f22-9043-92ab6980d2ec" CreationDate="2014-03-06T18:08:46.473" UserId="3474" Comment="added 781 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because intermediate buffers only need to be large enough to decode one line of text at once. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="62701439" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ee7ed01e-4082-410c-a437-55bc12e99ef3" CreationDate="2014-04-12T00:35:02.593" UserId="3474" Comment="deleted 23 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because intermediate buffers only need to be large enough to decode one line of text at once. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="62701614" PostHistoryTypeId="5" PostId="326440" RevisionGUID="7aa6780c-effc-4430-bef5-57f9bc05c74b" CreationDate="2014-04-12T00:42:19.543" UserId="3474" Comment="deleted 23 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="84817726" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ad64ac24-0039-42e1-96b7-3a4a3bc56866" CreationDate="2015-02-28T18:41:59.680" UserId="59087" Comment="added 27 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    import java.nio.file.Files;&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="84930034" PostHistoryTypeId="8" PostId="326440" RevisionGUID="92cc156c-0db6-4f27-a298-f1d3443e02fc" CreationDate="2015-03-02T16:39:54.157" UserId="3474" Comment="Rollback to [7aa6780c-effc-4430-bef5-57f9bc05c74b]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="118153554" PostHistoryTypeId="5" PostId="326440" RevisionGUID="81625e81-df58-4835-86b0-50f45ecbc886" CreationDate="2016-05-16T01:24:17.877" UserDisplayName="user719662" Comment="added 7 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    public static String readFile(String path, Charset encoding)&#xD;&#xA;        throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="118159104" PostHistoryTypeId="8" PostId="326440" RevisionGUID="f59a46ed-e226-4720-9670-a672cf8cf72a" CreationDate="2016-05-16T04:40:32.017" UserId="3474" Comment="Rollback to [92cc156c-0db6-4f27-a298-f1d3443e02fc]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="159719814" PostHistoryTypeId="5" PostId="326440" RevisionGUID="4e8aca7b-dd39-4a00-93e9-be80269288ab" CreationDate="2017-11-02T15:38:25.903" UserId="3474" Comment="added 612 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;In Java 8, `BufferedReader` added a new method, [`lines()`][2] to produce a `Stream&lt;String&gt;`. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (BufferedReader r = Files.newBufferedReader(path, encoding)) {&#xD;&#xA;      r.lines().forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][4] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][5] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [5]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="192814542" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5f288f8b-80fa-4834-98e7-24b3733bd4ef" CreationDate="2019-03-03T16:51:37.817" UserId="3474" Comment="deleted 44 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][2] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][4] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][5] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][6] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][7] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [6]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [7]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 4.0" />
  <row Id="225638972" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5b99fcc3-547f-45f4-86e8-f37d3361f631" CreationDate="2020-07-01T08:42:39.983" UserId="775954" Comment="grammar, make links HTTPS" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="231695210" PostHistoryTypeId="5" PostId="326440" RevisionGUID="12cb516c-bd2e-46e1-ae58-0c253deeeb7c" CreationDate="2020-09-28T03:23:26.580" UserId="714112" Comment="Clarify what package contains class." Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    import java.nio.file.Files;&#xD;&#xA;    ..&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="231735883" PostHistoryTypeId="8" PostId="326440" RevisionGUID="f3d71a41-face-4ac4-a66e-42f94c19c6e3" CreationDate="2020-09-28T15:31:38.653" UserId="3474" Comment="Rollback to [5b99fcc3-547f-45f4-86e8-f37d3361f631]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
</posthistory>
