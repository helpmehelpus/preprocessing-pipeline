<?xml version="1.0" encoding="utf-8"?>
<posthistory>
  <row Id="7874570" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1658830c-b8e9-46cb-8797-c73152caec26" CreationDate="2010-09-21T10:47:31.883" UserId="276052" Comment="added 193 characters in body; added 42 characters in body; added 19 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;;&#xD;&#xA;        prefix = prefix.charAt(power-1) + (si ? &quot;B&quot; : &quot;iB&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="22587012" PostHistoryTypeId="5" PostId="9875710" RevisionGUID="52a2dc0a-5d0b-4c6b-ad53-40a9b928ad86" CreationDate="2012-03-26T17:39:49.437" UserId="900807" Comment="added 422 characters in body" Text="I have a nice jQuery Extension perfect for this type of thing at this gist:&#xD;&#xA;&#xD;&#xA;&gt; https://gist.github.com/2206057&#xD;&#xA;&#xD;&#xA;To use it just do something like:&#xD;&#xA;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(); // will return current cursor state for that element&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;pointer&quot;); // will change ele cursor to whatever is &quot;&quot;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;clear&quot;); // will change ele cursor to default&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;ishover&quot;); // will return boolean of if mouse is over element or not&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;position&quot;); // will return cursor's current position in &quot;relation&quot; to element&#xD;&#xA;&#xD;&#xA;also &#xD;&#xA;&#xD;&#xA;    $.cursor(&quot;wait&quot;) // will change document cursor to whatever is &quot;&quot;&#xD;&#xA;    $.cursor($(&quot;#eleID&quot;), &quot;wait&quot;); // same as $(&quot;#eleID&quot;).cursor(&quot;wait&quot;);&#xD;&#xA;    $.cursor(&quot;position&quot;) // will return current cursor position&#xD;&#xA;&#xD;&#xA;should also mention, if you submit multiple elements like `$(&quot;#eleID1, .elementsWiththisClass&quot;)` for &quot;position&quot; and &quot;isHover&quot; then it will return an `Array` containing objects like:&#xD;&#xA;&#xD;&#xA;    var poses = $(&quot;#eleID1, .elementsWiththisClass&quot;).cursor(&quot;position&quot;) //  will equal&#xD;&#xA;    poses[0] = {&#xD;&#xA;        ele: e.fn.e.init[1], // the jquery element&#xD;&#xA;        x: XXX, //  where XXX is the cursors current position in relation to element&#xD;&#xA;        y: XXX&#xD;&#xA;    }&#xD;&#xA;    poses[1] = { // ...and so on and so forth for each element" ContentLicense="CC BY-SA 3.0" />
  <row Id="7873162" PostHistoryTypeId="2" PostId="3758880" RevisionGUID="038858fc-3127-4011-be25-d8e8e74a7662" CreationDate="2010-09-21T09:22:21.483" UserId="276052" Text="Here is my go at it:&#xD;&#xA;&#xD;&#xA;    private static String[] prefix = new String[] {&quot;&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;};&#xD;&#xA;    &#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        if (bytes == 0) return &quot;0 B&quot;;&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = prefix[(int) power] + (si &amp;&amp; power &gt; 0 ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        String format = power == 0 ? &quot;%.0f %s&quot; : &quot;%.1f %s&quot;;&#xD;&#xA;        return String.format(format, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;&#xD;&#xA;The following lines:&#xD;&#xA;&#xD;&#xA;    for (long i = 0; i &lt; 10000000000000L; i = i == 0 ? 3 : i * 5)&#xD;&#xA;        System.out.printf(&quot;%14d: %10s %10s%n&quot;, i,&#xD;&#xA;                humanByteCount(i, true), humanByteCount(i, false));&#xD;&#xA;&#xD;&#xA;Prints&#xD;&#xA;&#xD;&#xA;                 0:        0 B        0 B&#xD;&#xA;                 3:        3 B        3 B&#xD;&#xA;                15:       15 B       15 B&#xD;&#xA;                75:       75 B       75 B&#xD;&#xA;               375:      375 B      375 B&#xD;&#xA;              1875:    1.9 KiB     1.8 KB&#xD;&#xA;              9375:    9.4 KiB     9.2 KB&#xD;&#xA;             46875:   46.9 KiB    45.8 KB&#xD;&#xA;            234375:  234.4 KiB   228.9 KB&#xD;&#xA;           1171875:    1.2 MiB     1.1 MB&#xD;&#xA;           5859375:    5.9 MiB     5.6 MB&#xD;&#xA;          29296875:   29.3 MiB    27.9 MB&#xD;&#xA;         146484375:  146.5 MiB   139.7 MB&#xD;&#xA;         732421875:  732.4 MiB   698.5 MB&#xD;&#xA;        3662109375:    3.7 GiB     3.4 GB&#xD;&#xA;       18310546875:   18.3 GiB    17.1 GB&#xD;&#xA;       91552734375:   91.6 GiB    85.3 GB&#xD;&#xA;      457763671875:  457.8 GiB   426.3 GB&#xD;&#xA;     2288818359375:    2.3 TiB     2.1 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873319" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="be00e77b-fbda-4803-a59e-cc202db1b43c" CreationDate="2010-09-21T09:31:09.437" UserId="276052" Comment="deleted 206 characters in body" Text="Here is my go at it:&#xD;&#xA;&#xD;&#xA;    private static String[] prefix = new String[] {&quot;&quot;,&quot;K&quot;,&quot;M&quot;,&quot;G&quot;,&quot;T&quot;,&quot;P&quot;,&quot;E&quot;};&#xD;&#xA;    &#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        if (bytes == 0) return &quot;0 B&quot;;&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = prefix[(int) power] + (si &amp;&amp; power &gt; 0 ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        String format = power == 0 ? &quot;%.0f %s&quot; : &quot;%.1f %s&quot;;&#xD;&#xA;        return String.format(format, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                 0:        0 B        0 B&#xD;&#xA;                 3:        3 B        3 B&#xD;&#xA;                15:       15 B       15 B&#xD;&#xA;                75:       75 B       75 B&#xD;&#xA;               375:      375 B      375 B&#xD;&#xA;              1875:    1.9 KiB     1.8 KB&#xD;&#xA;              9375:    9.4 KiB     9.2 KB&#xD;&#xA;             46875:   46.9 KiB    45.8 KB&#xD;&#xA;            234375:  234.4 KiB   228.9 KB&#xD;&#xA;           1171875:    1.2 MiB     1.1 MB&#xD;&#xA;           5859375:    5.9 MiB     5.6 MB&#xD;&#xA;          29296875:   29.3 MiB    27.9 MB&#xD;&#xA;         146484375:  146.5 MiB   139.7 MB&#xD;&#xA;         732421875:  732.4 MiB   698.5 MB&#xD;&#xA;        3662109375:    3.7 GiB     3.4 GB&#xD;&#xA;       18310546875:   18.3 GiB    17.1 GB&#xD;&#xA;       91552734375:   91.6 GiB    85.3 GB&#xD;&#xA;      457763671875:  457.8 GiB   426.3 GB&#xD;&#xA;     2288818359375:    2.3 TiB     2.1 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873489" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1324adaa-9d8d-4f5c-8130-1dd4676ae1d4" CreationDate="2010-09-21T09:42:57.160" UserId="276052" Comment="deleted 338 characters in body; deleted 79 characters in body; added 41 characters in body" Text="Here is my go at it (handles both si units and binary units):&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public static String humanByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        double power = Math.min(Math.floor(Math.log(bytes)/Math.log(unit)), 6);&#xD;&#xA;        String pref = &quot;KMGTPE&quot;.charAt((int) power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), pref);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                   1:        1 B        1 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873581" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1b2eebee-64f6-4565-b6cf-6ea41a153bd8" CreationDate="2010-09-21T09:49:12.813" UserId="276052" Comment="deleted 26 characters in body; added 4 characters in body; added 8 characters in body; added 13 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = &quot;KMGTPE&quot;.charAt(power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                   1:        1 B        1 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="22585938" PostHistoryTypeId="5" PostId="9875710" RevisionGUID="1cb680a0-3cf0-433f-942d-467b03fc9a64" CreationDate="2012-03-26T17:09:08.107" UserId="900807" Comment="added 721 characters in body" Text="I have a nice jQuery Extension perfect for this type of thing at this gist:&#xD;&#xA;&#xD;&#xA;&gt; https://gist.github.com/2206057&#xD;&#xA;&#xD;&#xA;To use it just do something like:&#xD;&#xA;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(); // will return current cursor state for that element&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;pointer&quot;); // will change ele cursor to whatever is &quot;&quot;&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;clear&quot;); // will change ele cursor to default&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;ishover&quot;); // will return boolean of if mouse is over element or not&#xD;&#xA;    $(&quot;#eleID&quot;).cursor(&quot;position&quot;); // will return current cursor position in &quot;relation&quot; to element&#xD;&#xA;&#xD;&#xA;also &#xD;&#xA;&#xD;&#xA;    $.cursor(&quot;wait&quot;) // will change document cursor to whatever is &quot;&quot;&#xD;&#xA;    $.cursor($(&quot;#eleID&quot;), &quot;wait&quot;); // same as $(&quot;#eleID&quot;).cursor(&quot;wait&quot;);&#xD;&#xA;    $.cursor(&quot;position&quot;) // will return current cursor position" ContentLicense="CC BY-SA 3.0" />
  <row Id="7874248" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="800ccb7a-67f4-467d-a69a-8b9ab7972e41" CreationDate="2010-09-21T10:27:59.107" UserId="276052" Comment="deleted 45 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String prefix = &quot;KMGTPE&quot;.charAt(power-1) + (si ? &quot;iB&quot; : &quot;B&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %s&quot;, bytes / Math.pow(unit, power), prefix);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                   0:        0 B        0 B&#xD;&#xA;                  17:       17 B       17 B&#xD;&#xA;                 289:      289 B      289 B&#xD;&#xA;                4913:    4.9 KiB     4.8 KB&#xD;&#xA;               83521:   83.5 KiB    81.6 KB&#xD;&#xA;             1419857:    1.4 MiB     1.4 MB&#xD;&#xA;            24137569:   24.1 MiB    23.0 MB&#xD;&#xA;           410338673:  410.3 MiB   391.3 MB&#xD;&#xA;          6975757441:    7.0 GiB     6.5 GB&#xD;&#xA;        118587876497:  118.6 GiB   110.4 GB&#xD;&#xA;       2015993900449:    2.0 TiB     1.8 TB&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7874704" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="d00ea2b0-2bcb-4eb9-aa15-41d989f40ff1" CreationDate="2010-09-21T10:55:46.207" UserId="276052" Comment="deleted 39 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int power = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        return String.format(&quot;%.1f %s%s&quot;, bytes / Math.pow(unit, power),&#xD;&#xA;                (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(power-1), si ? &quot;B&quot; : &quot;iB&quot;);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="200451414" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ba112991-749b-490b-8021-ea5c43ab192e" CreationDate="2019-06-26T21:51:28.527" UserId="3474" Comment="added 358 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 4.0" />
  <row Id="7875126" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="86947e50-9558-4cef-854e-542d31a6c50e" CreationDate="2010-09-21T11:22:55.253" UserId="276052" Comment="added 2 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 KB     1000 B&#xD;&#xA;                    1023:     1.0 KB     1023 B&#xD;&#xA;                    1024:     1.0 KB    1.0 KiB&#xD;&#xA;                    1728:     1.7 KB    1.7 KiB&#xD;&#xA;                  110592:   110.6 KB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="15577610" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="60eb1817-04bd-47ca-a93a-d49c13fbe9d4" CreationDate="2011-08-17T14:59:59.883" UserId="276052" Comment="edited body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 kB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
  <row Id="24534909" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="56de0e8d-0f69-4030-ab0f-92bd315394aa" CreationDate="2012-05-17T18:59:28.427" UserId="157882" Comment="Fixed typo" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
  <row Id="228647569" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="4a06b7d5-9422-4698-9780-387e54d95f07" CreationDate="2020-08-12T18:34:38.667" UserId="63550" Comment="Active reading." Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide][2]&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;  [1]: https://programming.guide/worlds-most-copied-so-snippet.html&#xD;&#xA;  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="130380462" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="4eaf6394-79cb-41c2-b209-601bace34bfc" CreationDate="2016-10-29T03:58:01.857" UserId="276052" Comment="added 161 characters in body" Text="Here is my go at it (no loops and handles both SI units and binary units):&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCount(long bytes, boolean si) {&#xD;&#xA;        int unit = si ? 1000 : 1024;&#xD;&#xA;        if (bytes &lt; unit) return bytes + &quot; B&quot;;&#xD;&#xA;        int exp = (int) (Math.log(bytes) / Math.log(unit));&#xD;&#xA;        String pre = (si ? &quot;kMGTPE&quot; : &quot;KMGTPE&quot;).charAt(exp-1) + (si ? &quot;&quot; : &quot;i&quot;);&#xD;&#xA;        return String.format(&quot;%.1f %sB&quot;, bytes / Math.pow(unit, exp), pre);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Related article: [Java: Formatting byte size to human readable format](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)" ContentLicense="CC BY-SA 3.0" />
  <row Id="210418581" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="1510319a-551c-4ea1-bb72-9e67122bf2ba" CreationDate="2019-12-02T23:57:39.337" UserId="276052" Comment="added 1136 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        return bytes &lt; 1000L ? bytes + &quot; B&quot;&#xD;&#xA;                : bytes &lt; 999_950L ? String.format(&quot;%.1f kB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f MB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f GB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f TB&quot;, bytes / 1e3)&#xD;&#xA;                : (bytes /= 1000) &lt; 999_950L ? String.format(&quot;%.1f PB&quot;, bytes / 1e3)&#xD;&#xA;                : String.format(&quot;%.1f EB&quot;, bytes / 1e6);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        return bytes &lt; 1024L ? bytes + &quot; B&quot;&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 40 ? String.format(&quot;%.1f KiB&quot;, bytes / 0x1p10)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 30 ? String.format(&quot;%.1f MiB&quot;, bytes / 0x1p20)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 20 ? String.format(&quot;%.1f GiB&quot;, bytes / 0x1p30)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL &gt;&gt; 10 ? String.format(&quot;%.1f TiB&quot;, bytes / 0x1p40)&#xD;&#xA;                : bytes &lt; 0xfffccccccccccccL ? String.format(&quot;%.1f PiB&quot;, (bytes &gt;&gt; 10) / 0x1p40)&#xD;&#xA;                : String.format(&quot;%.1f EiB&quot;, (bytes &gt;&gt; 20) / 0x1p40);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="210660032" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="f726a5eb-c96b-4613-ae53-f1e4cf3cf3bb" CreationDate="2019-12-06T05:24:51.067" UserId="276052" Comment="added 163 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        String s = bytes &lt; 0 ? &quot;-&quot; : &quot;&quot;;&#xD;&#xA;        long b = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        return b &lt; 1000L ? bytes + &quot; B&quot;&#xD;&#xA;                : b &lt; 999_950L ? String.format(&quot;%s%.1f kB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f MB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f GB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f TB&quot;, s, b / 1e3)&#xD;&#xA;                : (b /= 1000) &lt; 999_950L ? String.format(&quot;%s%.1f PB&quot;, s, b / 1e3)&#xD;&#xA;                : String.format(&quot;%s%.1f EB&quot;, s, b / 1e6);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long b = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        return b &lt; 1024L ? bytes + &quot; B&quot;&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 40 ? String.format(&quot;%.1f KiB&quot;, bytes / 0x1p10)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 30 ? String.format(&quot;%.1f MiB&quot;, bytes / 0x1p20)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 20 ? String.format(&quot;%.1f GiB&quot;, bytes / 0x1p30)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL &gt;&gt; 10 ? String.format(&quot;%.1f TiB&quot;, bytes / 0x1p40)&#xD;&#xA;                : b &lt;= 0xfffccccccccccccL ? String.format(&quot;%.1f PiB&quot;, (bytes &gt;&gt; 10) / 0x1p40)&#xD;&#xA;                : String.format(&quot;%.1f EiB&quot;, (bytes &gt;&gt; 20) / 0x1p40);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="217505446" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="fc80a938-014a-4b2d-a71c-ee168ea617c1" CreationDate="2020-03-23T15:00:26.887" UserId="276052" Comment="deleted 420 characters in body" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied StackOverflow snippet of all time is flawed!](https://programming.guide/worlds-most-copied-so-snippet.html)&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide](http://programming.guide/java/formatting-byte-size-to-human-readable-format.html)&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 K = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="235940485" PostHistoryTypeId="5" PostId="3758880" RevisionGUID="59426900-524d-4bf2-afbe-e05ac2dd6e56" CreationDate="2020-11-30T10:29:35.070" UserId="648265" Comment="fix designation to correspond to what the code produces" Text="&gt; **Fun fact:** The original snippet posted here was the most copied Java snippet of all time on Stack Overflow, and it was flawed. It was fixed, but it got messy.&#xD;&#xA;&gt;&#xD;&#xA;&gt; Full story in this article: [The most copied Stack Overflow snippet of all time is flawed!][1]&#xD;&#xA;&#xD;&#xA;Source: [Formatting byte size to human readable format | Programming.Guide][2]&#xD;&#xA;&#xD;&#xA;# SI (1 k = 1,000)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountSI(long bytes) {&#xD;&#xA;        if (-1000 &lt; bytes &amp;&amp; bytes &lt; 1000) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;kMGTPE&quot;);&#xD;&#xA;        while (bytes &lt;= -999_950 || bytes &gt;= 999_950) {&#xD;&#xA;            bytes /= 1000;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        return String.format(&quot;%.1f %cB&quot;, bytes / 1000.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;# Binary (1 Ki = 1,024)&#xD;&#xA;&#xD;&#xA;    public static String humanReadableByteCountBin(long bytes) {&#xD;&#xA;        long absB = bytes == Long.MIN_VALUE ? Long.MAX_VALUE : Math.abs(bytes);&#xD;&#xA;        if (absB &lt; 1024) {&#xD;&#xA;            return bytes + &quot; B&quot;;&#xD;&#xA;        }&#xD;&#xA;        long value = absB;&#xD;&#xA;        CharacterIterator ci = new StringCharacterIterator(&quot;KMGTPE&quot;);&#xD;&#xA;        for (int i = 40; i &gt;= 0 &amp;&amp; absB &gt; 0xfffccccccccccccL &gt;&gt; i; i -= 10) {&#xD;&#xA;            value &gt;&gt;= 10;&#xD;&#xA;            ci.next();&#xD;&#xA;        }&#xD;&#xA;        value *= Long.signum(bytes);&#xD;&#xA;        return String.format(&quot;%.1f %ciB&quot;, value / 1024.0, ci.current());&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;# Example output:&#xD;&#xA;&#xD;&#xA;                                  SI     BINARY&#xD;&#xA;&#xD;&#xA;                       0:        0 B        0 B&#xD;&#xA;                      27:       27 B       27 B&#xD;&#xA;                     999:      999 B      999 B&#xD;&#xA;                    1000:     1.0 kB     1000 B&#xD;&#xA;                    1023:     1.0 kB     1023 B&#xD;&#xA;                    1024:     1.0 kB    1.0 KiB&#xD;&#xA;                    1728:     1.7 kB    1.7 KiB&#xD;&#xA;                  110592:   110.6 kB  108.0 KiB&#xD;&#xA;                 7077888:     7.1 MB    6.8 MiB&#xD;&#xA;               452984832:   453.0 MB  432.0 MiB&#xD;&#xA;             28991029248:    29.0 GB   27.0 GiB&#xD;&#xA;           1855425871872:     1.9 TB    1.7 TiB&#xD;&#xA;     9223372036854775807:     9.2 EB    8.0 EiB   (Long.MAX_VALUE)&#xD;&#xA;&#xD;&#xA;  [1]: https://programming.guide/worlds-most-copied-so-snippet.html&#xD;&#xA;  [2]: http://programming.guide/java/formatting-byte-size-to-human-readable-format.html&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="22583841" PostHistoryTypeId="2" PostId="9875710" RevisionGUID="b77c0329-4369-4ae7-9947-72738e2c02e7" CreationDate="2012-03-26T16:11:16.270" UserId="900807" Text="&lt;script src=&quot;https://gist.github.com/2206057.js?file=jqExtCursor.js&quot;&gt;&lt;/script&gt;" ContentLicense="CC BY-SA 3.0" />
  <row Id="167328771" PostHistoryTypeId="5" PostId="326440" RevisionGUID="028e71c4-b697-4770-910f-97d6b3bd9036" CreationDate="2018-02-20T22:51:08.997" UserId="3474" Comment="added 622 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;In Java 8, `BufferedReader` added a new method, [`lines()`][2] to produce a `Stream&lt;String&gt;`. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (BufferedReader r = Files.newBufferedReader(path, encoding)) {&#xD;&#xA;      r.lines().forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;There is also a `Files.lines()` method which does something very similar, returning the `Stream&lt;String&gt;` directly. But I don't like it. The `Stream` needs a `close()` call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. So your code would look very similar, like this:&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;The difference is that you have a `Stream` assigned to a variable, and I try avoid that as a practice so that I don't accidentally try to invoke the stream twice.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][4] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][5] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [5]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="22583844" PostHistoryTypeId="12" PostId="9875710" RevisionGUID="b6403345-559b-44c5-9daa-253e63fbfbfe" CreationDate="2012-03-26T16:11:20.420" UserId="900807" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:900807,&quot;DisplayName&quot;:&quot;SpYk3HH&quot;}]}" />
  <row Id="22585948" PostHistoryTypeId="13" PostId="9875710" RevisionGUID="e20f5cce-70bc-4815-873d-8f62df4893eb" CreationDate="2012-03-26T17:09:19.963" UserId="900807" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:900807,&quot;DisplayName&quot;:&quot;SpYk3HH&quot;}]}" />
  <row Id="522158" PostHistoryTypeId="2" PostId="326440" RevisionGUID="4320894b-887d-49b9-b4f9-6fffbdd5c762" CreationDate="2008-11-28T18:56:13.693" UserId="3474" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = new .getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="522159" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ece84de0-3535-47ac-be79-b84b0a413183" CreationDate="2008-11-28T19:05:55.017" UserId="3474" Comment="Fix a typo in code." Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="522160" PostHistoryTypeId="5" PostId="326440" RevisionGUID="185326f5-11c1-41c6-a14d-b2f98f6a29fb" CreationDate="2008-11-28T19:13:16.747" UserId="3474" Comment="Fix another part of the same typo." Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return CharSet.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="3890740" PostHistoryTypeId="5" PostId="326440" RevisionGUID="079c73bd-640b-49db-a9e3-b089d3ffe907" CreationDate="2009-12-21T03:52:07.540" UserId="3474" Comment="edited body" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return Charset.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="40278052" PostHistoryTypeId="5" PostId="326440" RevisionGUID="0cbeee87-efcd-47f6-b879-f10ba850dedb" CreationDate="2013-05-07T18:58:22.013" UserId="3474" Comment="added 558 characters in body" Text="In general, you should specify the character encoding to use when converting the bytes of a file to text. There are some special cases when you just want to use the platform default, but they are rare, and you should be able to explicitly justify why this is okay.&#xD;&#xA;&#xD;&#xA;Anyway, here's an efficient way to it:&#xD;&#xA;&#xD;&#xA;    private static String readFile(String path) throws IOException {&#xD;&#xA;      FileInputStream stream = new FileInputStream(new File(path));&#xD;&#xA;      try {&#xD;&#xA;        FileChannel fc = stream.getChannel();&#xD;&#xA;        MappedByteBuffer bb = fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size());&#xD;&#xA;        /* Instead of using default, pass in a decoder. */&#xD;&#xA;        return Charset.defaultCharset().decode(bb).toString();&#xD;&#xA;      }&#xD;&#xA;      finally {&#xD;&#xA;        stream.close();&#xD;&#xA;      }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;&#xD;&#xA;In Java 7, [a utility method has been added to read all &quot;lines&quot; from a file,][1] as a `List&lt;String&gt;`. This isn't exactly the same thing; some information is lost because the actual line terminators are discarded. It is, however, a robust and convenient implementation of an extremely common use case:&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = &#xD;&#xA;      Files.readAllLines(Paths.get(&quot;smallfile.txt&quot;), StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="40414907" PostHistoryTypeId="5" PostId="326440" RevisionGUID="667dea6c-5c31-4709-aaf6-ddb652cdce10" CreationDate="2013-05-10T07:08:42.820" UserId="3474" Comment="added 403 characters in body" Text="Here's a compact, robust idiom for Java 7, wrapped up in method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This method can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][1] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][2] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="40486052" PostHistoryTypeId="5" PostId="326440" RevisionGUID="cbb5f92a-9c7b-499b-b582-568b1afeed93" CreationDate="2013-05-11T18:43:04.003" UserId="3474" Comment="added 10 characters in body" Text="Read text from a file&#xD;&#xA;---------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;This method can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][1] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][2] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="59731823" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5da3e505-d708-4f22-9043-92ab6980d2ec" CreationDate="2014-03-06T18:08:46.473" UserId="3474" Comment="added 781 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return encoding.decode(ByteBuffer.wrap(encoded)).toString();&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because intermediate buffers only need to be large enough to decode one line of text at once. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="62701439" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ee7ed01e-4082-410c-a437-55bc12e99ef3" CreationDate="2014-04-12T00:35:02.593" UserId="3474" Comment="deleted 23 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), the decoded characters (a character buffer), and a copy of the character data (in the new `String` instance) all reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because intermediate buffers only need to be large enough to decode one line of text at once. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="62701614" PostHistoryTypeId="5" PostId="326440" RevisionGUID="7aa6780c-effc-4430-bef5-57f9bc05c74b" CreationDate="2014-04-12T00:42:19.543" UserId="3474" Comment="deleted 23 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="84817726" PostHistoryTypeId="5" PostId="326440" RevisionGUID="ad64ac24-0039-42e1-96b7-3a4a3bc56866" CreationDate="2015-02-28T18:41:59.680" UserId="59087" Comment="added 27 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    import java.nio.file.Files;&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="84930034" PostHistoryTypeId="8" PostId="326440" RevisionGUID="92cc156c-0db6-4f27-a298-f1d3443e02fc" CreationDate="2015-03-02T16:39:54.157" UserId="3474" Comment="Rollback to [7aa6780c-effc-4430-bef5-57f9bc05c74b]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="118153554" PostHistoryTypeId="5" PostId="326440" RevisionGUID="81625e81-df58-4835-86b0-50f45ecbc886" CreationDate="2016-05-16T01:24:17.877" UserDisplayName="user719662" Comment="added 7 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    public static String readFile(String path, Charset encoding)&#xD;&#xA;        throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="118159104" PostHistoryTypeId="8" PostId="326440" RevisionGUID="f59a46ed-e226-4720-9670-a672cf8cf72a" CreationDate="2016-05-16T04:40:32.017" UserId="3474" Comment="Rollback to [92cc156c-0db6-4f27-a298-f1d3443e02fc]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM.&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][2] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][3] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [3]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="159719814" PostHistoryTypeId="5" PostId="326440" RevisionGUID="4e8aca7b-dd39-4a00-93e9-be80269288ab" CreationDate="2017-11-02T15:38:25.903" UserId="3474" Comment="added 612 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;In Java 8, `BufferedReader` added a new method, [`lines()`][2] to produce a `Stream&lt;String&gt;`. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (BufferedReader r = Files.newBufferedReader(path, encoding)) {&#xD;&#xA;      r.lines().forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][4] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][5] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [5]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 3.0" />
  <row Id="192814542" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5f288f8b-80fa-4834-98e7-24b3733bd4ef" CreationDate="2019-03-03T16:51:37.817" UserId="3474" Comment="deleted 44 characters in body" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;&#xD;&#xA;Here's a compact, robust idiom for Java 7, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding) &#xD;&#xA;      throws IOException &#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][1] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][2] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][3], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][4] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][5] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][6] class define some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][7] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [2]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [6]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [7]: http://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29" ContentLicense="CC BY-SA 4.0" />
  <row Id="225638972" PostHistoryTypeId="5" PostId="326440" RevisionGUID="5b99fcc3-547f-45f4-86e8-f37d3361f631" CreationDate="2020-07-01T08:42:39.983" UserId="775954" Comment="grammar, make links HTTPS" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="231695210" PostHistoryTypeId="5" PostId="326440" RevisionGUID="12cb516c-bd2e-46e1-ae58-0c253deeeb7c" CreationDate="2020-09-28T03:23:26.580" UserId="714112" Comment="Clarify what package contains class." Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    import java.nio.file.Files;&#xD;&#xA;    ..&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="231735883" PostHistoryTypeId="8" PostId="326440" RevisionGUID="f3d71a41-face-4ac4-a66e-42f94c19c6e3" CreationDate="2020-09-28T15:31:38.653" UserId="3474" Comment="Rollback to [5b99fcc3-547f-45f4-86e8-f37d3361f631]" Text="Read all text from a file&#xD;&#xA;-------------------------&#xD;&#xA;Java 11 added the [readString()][1] method to read small files as a `String`, preserving line terminators:&#xD;&#xA;&#xD;&#xA;    String content = Files.readString(path, StandardCharsets.US_ASCII);&#xD;&#xA;&#xD;&#xA;For versions between Java 7 and 11, here's a compact, robust idiom, wrapped up in a utility method:&#xD;&#xA;&#xD;&#xA;    static String readFile(String path, Charset encoding)&#xD;&#xA;      throws IOException&#xD;&#xA;    {&#xD;&#xA;      byte[] encoded = Files.readAllBytes(Paths.get(path));&#xD;&#xA;      return new String(encoded, encoding);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Read lines of text from a file&#xD;&#xA;------------------------------&#xD;&#xA;&#xD;&#xA;Java 7 added a [convenience method to read a file as lines of text,][2] represented as a `List&lt;String&gt;`. This approach is &quot;lossy&quot; because the line separators are stripped from the end of each line.&#xD;&#xA;&#xD;&#xA;    List&lt;String&gt; lines = Files.readAllLines(Paths.get(path), encoding);&#xD;&#xA;&#xD;&#xA;Java 8 added the [`Files.lines()`][3] method to produce a `Stream&lt;String&gt;`. Again, this method is lossy because line separators are stripped. If an `IOException` is encountered while reading the file, it is wrapped in an [`UncheckedIOException`][4], since `Stream` doesn't accept lambdas that throw checked exceptions.&#xD;&#xA;&#xD;&#xA;    try (Stream&lt;String&gt; lines = Files.lines(path, encoding)) {&#xD;&#xA;      lines.forEach(System.out::println);&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;This `Stream` does need a [`close()`][5] call; this is poorly documented on the API, and I suspect many people don't even notice `Stream` has a `close()` method. Be sure to use an ARM-block as shown.&#xD;&#xA;&#xD;&#xA;If you are working with a source other than a file, you can use the [`lines()`][6] method in `BufferedReader` instead.&#xD;&#xA;&#xD;&#xA;Memory utilization&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;The first method, that preserves line breaks, can temporarily require memory several times the size of the file, because for a short time the raw file contents (a byte array), and the decoded characters (each of which is 16 bits even if encoded as 8 bits in the file) reside in memory at once. It is safest to apply to files that you know to be small relative to the available memory.&#xD;&#xA;&#xD;&#xA;The second method, reading lines, is usually more memory efficient, because the input byte buffer for decoding doesn't need to contain the entire file. However, it's still not suitable for files that are very large relative to available memory.&#xD;&#xA;&#xD;&#xA;For reading large files, you need a different design for your program, one that reads a chunk of text from a stream, processes it, and then moves on to the next, reusing the same fixed-sized memory block. Here, &quot;large&quot; depends on the computer specs. Nowadays, this threshold might be many gigabytes of RAM. The third method, using a `Stream&lt;String&gt;` is one way to do this, if your input &quot;records&quot; happen to be individual lines. (Using the `readLine()` method of `BufferedReader` is the procedural equivalent to this approach.)&#xD;&#xA;&#xD;&#xA;Character encoding&#xD;&#xA;------------------&#xD;&#xA;&#xD;&#xA;One thing that is missing from the sample in the original post is the character encoding. There are some special cases where the platform default is what you want, but they are rare, and you should be able justify your choice.&#xD;&#xA;&#xD;&#xA;The [`StandardCharsets`][7] class defines some constants for the encodings required of all Java runtimes:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, StandardCharsets.UTF_8);&#xD;&#xA;&#xD;&#xA;The platform default is available from [the `Charset` class][8] itself:&#xD;&#xA;&#xD;&#xA;    String content = readFile(&quot;test.txt&quot;, Charset.defaultCharset());&#xD;&#xA;&#xD;&#xA;---&#xD;&#xA;Note: This answer largely replaces my Java 6 version. The utility of Java 7 safely simplifies the code, and the old answer, which used a mapped byte buffer, prevented the file that was read from being deleted until the mapped buffer was garbage collected. You can view the old version via the &quot;edited&quot; link on this answer.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/file/Files.html#readString(java.nio.file.Path,java.nio.charset.Charset)&#xD;&#xA;  [2]: https://docs.oracle.com/javase/7/docs/api/java/nio/file/Files.html#readAllLines%28java.nio.file.Path,%20java.nio.charset.Charset%29&#xD;&#xA;  [3]: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-&#xD;&#xA;  [4]: https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html&#xD;&#xA;  [5]: https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--&#xD;&#xA;  [6]: https://docs.oracle.com/javase/8/docs/api/java/io/BufferedReader.html#lines--&#xD;&#xA;  [7]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/StandardCharsets.html&#xD;&#xA;  [8]: https://docs.oracle.com/javase/7/docs/api/java/nio/charset/Charset.html#defaultCharset%28%29&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="7872560" PostHistoryTypeId="2" PostId="3758606" RevisionGUID="444ab3fd-d608-4687-9834-c2dabe431a41" CreationDate="2010-09-21T08:42:59.537" UserId="404615" Text="How to convert byte size into human readable format in java?&#xD;&#xA;Like 1024 shoud become &quot;1Kb&quot; and 1024*1024 should become &quot;1Mb&quot;.&#xD;&#xA;&#xD;&#xA;(I am kind of sick of writing this utility method for each project.)&#xD;&#xA;I mean, are there any static methods in Apache Commons for this?&#xD;&#xA;&#xD;&#xA;Thanks." ContentLicense="CC BY-SA 2.5" />
  <row Id="7872561" PostHistoryTypeId="1" PostId="3758606" RevisionGUID="444ab3fd-d608-4687-9834-c2dabe431a41" CreationDate="2010-09-21T08:42:59.537" UserId="404615" Text="How to convert byte size into human readable format in java?" ContentLicense="CC BY-SA 2.5" />
  <row Id="7872562" PostHistoryTypeId="3" PostId="3758606" RevisionGUID="444ab3fd-d608-4687-9834-c2dabe431a41" CreationDate="2010-09-21T08:42:59.537" UserId="404615" Text="&lt;java&gt;&lt;formatting&gt;&lt;apache-commons&gt;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7872845" PostHistoryTypeId="5" PostId="3758606" RevisionGUID="c9833e94-35a9-4878-9b49-a58bd850f975" CreationDate="2010-09-21T09:01:13.053" UserId="28169" Comment="Spelling, grammar, brevity" Text="How to convert byte size into human-readable format in Java? Like 1024 should become &quot;1 Kb&quot; and 1024*1024 should become &quot;1 Mb&quot;.&#xD;&#xA;&#xD;&#xA;I am kind of sick of writing this utility method for each project. Are there any static methods in Apache Commons for this?&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="187753718" PostHistoryTypeId="6" PostId="3758606" RevisionGUID="0dfcae7d-02d7-445b-b53d-d1c06d6a7c1b" CreationDate="2018-12-13T12:39:24.083" UserId="185022" Comment="edited tags" Text="&lt;java&gt;&lt;android&gt;&lt;formatting&gt;&lt;apache-commons&gt;" ContentLicense="CC BY-SA 4.0" />
  <row Id="209846499" PostHistoryTypeId="9" PostId="3758606" RevisionGUID="7e2d4de5-c41f-45ae-a07f-88b2a3370611" CreationDate="2019-11-23T20:01:23.020" UserId="276052" Comment="Rollback to [c9833e94-35a9-4878-9b49-a58bd850f975]" Text="&lt;java&gt;&lt;formatting&gt;&lt;apache-commons&gt;" ContentLicense="CC BY-SA 4.0" />
  <row Id="210556406" PostHistoryTypeId="19" PostId="3758606" RevisionGUID="9fb6e230-36f9-441f-92e7-2899def87a26" CreationDate="2019-12-04T18:02:28.867" UserId="2680216" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:2680216,&quot;DisplayName&quot;:&quot;Josh Crozier&quot;}]}" />
  <row Id="210929856" PostHistoryTypeId="5" PostId="3758606" RevisionGUID="7527d540-9406-43c6-9b47-6fbdbca201d6" CreationDate="2019-12-10T14:22:25.783" UserId="814702" Comment="Fixed spelling." Text="How to convert byte size into human-readable format in Java? Like 1024 should become &quot;1 Kb&quot; and 1024*1024 should become &quot;1 Mb&quot;.&#xD;&#xA;&#xD;&#xA;I am kind of sick of writing this utility method for each project. Are there any static methods in [Apache Commons][1] for this?&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://commons.apache.org/" ContentLicense="CC BY-SA 4.0" />
  <row Id="210929857" PostHistoryTypeId="4" PostId="3758606" RevisionGUID="7527d540-9406-43c6-9b47-6fbdbca201d6" CreationDate="2019-12-10T14:22:25.783" UserId="814702" Comment="Fixed spelling." Text="How to convert byte size into human readable format in Java?" ContentLicense="CC BY-SA 4.0" />
  <row Id="228647469" PostHistoryTypeId="5" PostId="3758606" RevisionGUID="c0faf107-fde9-4a10-833d-338f420dabc5" CreationDate="2020-08-12T18:33:00.330" UserId="63550" Comment="Active reading. Fixed the question formation - missing auxiliary (or helping) verb - see e.g. &lt;https://www.youtube.com/watch?v=t4yWEt0OSpg&amp;t=1m49s&gt; (see also &lt;https://www.youtube.com/watch?v=kS5NfSzXfrI&gt; (QUASM)). " Text="How can I convert byte size into a human-readable format in Java?&#xD;&#xA;&#xD;&#xA;Like 1024 should become &quot;1 Kb&quot; and 1024*1024 should become &quot;1 Mb&quot;.&#xD;&#xA;&#xD;&#xA;I am kind of sick of writing this utility method for each project. Is there a static method in [Apache Commons][1] for this?&#xD;&#xA;&#xD;&#xA;  [1]: https://commons.apache.org/&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="228647470" PostHistoryTypeId="4" PostId="3758606" RevisionGUID="c0faf107-fde9-4a10-833d-338f420dabc5" CreationDate="2020-08-12T18:33:00.330" UserId="63550" Comment="Active reading. Fixed the question formation - missing auxiliary (or helping) verb - see e.g. &lt;https://www.youtube.com/watch?v=t4yWEt0OSpg&amp;t=1m49s&gt; (see also &lt;https://www.youtube.com/watch?v=kS5NfSzXfrI&gt; (QUASM)). " Text="How can I convert byte size into a human-readable format in Java?" ContentLicense="CC BY-SA 4.0" />
  <row Id="11329012" PostHistoryTypeId="2" PostId="5304668" RevisionGUID="2d584caf-4057-40da-b8e5-9f0a9969b8fc" CreationDate="2011-03-14T21:18:39.407" UserId="646222" Text="i want javascript code to detect the cursor type , for example when the cursor hover in textarea it change from default to text ..&#xD;&#xA;Regards ." ContentLicense="CC BY-SA 2.5" />
  <row Id="11329013" PostHistoryTypeId="1" PostId="5304668" RevisionGUID="2d584caf-4057-40da-b8e5-9f0a9969b8fc" CreationDate="2011-03-14T21:18:39.407" UserId="646222" Text="detect cursor type" ContentLicense="CC BY-SA 2.5" />
  <row Id="11329014" PostHistoryTypeId="3" PostId="5304668" RevisionGUID="2d584caf-4057-40da-b8e5-9f0a9969b8fc" CreationDate="2011-03-14T21:18:39.407" UserId="646222" Text="&lt;javascript&gt;&lt;jquery&gt;&lt;css&gt;&lt;cursor&gt;" ContentLicense="CC BY-SA 2.5" />
  <row Id="11329865" PostHistoryTypeId="5" PostId="5304668" RevisionGUID="8a667185-8c6e-4cb4-bd41-c5c5d6a9f2d2" CreationDate="2011-03-14T21:55:27.920" UserId="573261" Comment="deleted 15 characters in body" Text="I want JavaScript code to detect the cursor type.&#xD;&#xA;&#xD;&#xA;For example when the cursor hovers in textarea it changes from default to text .." ContentLicense="CC BY-SA 2.5" />
  <row Id="260695520" PostHistoryTypeId="5" PostId="5304668" RevisionGUID="7b37c59b-fa8f-417f-a947-7969dc657784" CreationDate="2021-12-24T18:13:21.457" UserId="4294399" Comment="added 49 characters in body; edited tags; edited title" Text="I want JavaScript code to detect the mouse cursor type.&#xD;&#xA;&#xD;&#xA;For example when the cursor hovers in `&lt;textarea&gt;` it changes from default to text. &#xD;&#xA;&#xD;&#xA;How would I go about detecting this?" ContentLicense="CC BY-SA 4.0" />
  <row Id="260695521" PostHistoryTypeId="4" PostId="5304668" RevisionGUID="7b37c59b-fa8f-417f-a947-7969dc657784" CreationDate="2021-12-24T18:13:21.457" UserId="4294399" Comment="added 49 characters in body; edited tags; edited title" Text="Detect mouse cursor type" ContentLicense="CC BY-SA 4.0" />
  <row Id="260695522" PostHistoryTypeId="6" PostId="5304668" RevisionGUID="7b37c59b-fa8f-417f-a947-7969dc657784" CreationDate="2021-12-24T18:13:21.457" UserId="4294399" Comment="added 49 characters in body; edited tags; edited title" Text="&lt;javascript&gt;&lt;jquery&gt;&lt;css&gt;&lt;mouse-cursor&gt;" ContentLicense="CC BY-SA 4.0" />
  <row Id="610149" PostHistoryTypeId="1" PostId="326390" RevisionGUID="3fb8be7e-dc66-46f7-a17f-98fe74406bf4" CreationDate="2008-11-28T18:32:07.253" UserId="20654" Text="Is there an alternative to this way of read file to a string in java?" ContentLicense="CC BY-SA 2.5" />
  <row Id="610150" PostHistoryTypeId="3" PostId="326390" RevisionGUID="3fb8be7e-dc66-46f7-a17f-98fe74406bf4" CreationDate="2008-11-28T18:32:07.253" UserId="20654" Text="&lt;java&gt;&lt;io&gt;" ContentLicense="CC BY-SA 2.5" />
  <row Id="610151" PostHistoryTypeId="2" PostId="326390" RevisionGUID="3fb8be7e-dc66-46f7-a17f-98fe74406bf4" CreationDate="2008-11-28T18:32:07.253" UserId="20654" Text="I've been using this idiom for some time now. And it seems to be the most wide spread at least in the sites I've visited. &#xD;&#xA;&#xD;&#xA;Does anyone have a better/different way to read a file into a string in Java.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Thanks&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;     private String readFile( String file ) throws IOException {&#xD;&#xA;        BufferedReader reader = new BufferedReader( new FileReader (file));&#xD;&#xA;        String line  = null;&#xD;&#xA;        StringBuilder stringBuilder = new StringBuilder();&#xD;&#xA;        String ls = System.getProperty(&quot;line.separator&quot;);&#xD;&#xA;        while( ( line = reader.readLine() ) != null ) {&#xD;&#xA;            stringBuilder.append( line );&#xD;&#xA;            stringBuilder.append( ls );&#xD;&#xA;        }&#xD;&#xA;        return stringBuilder.toString();&#xD;&#xA;     }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="610152" PostHistoryTypeId="4" PostId="326390" RevisionGUID="59b60e7d-807c-4c6b-8f18-5fc0a49654a1" CreationDate="2008-12-18T06:42:20.390" UserId="3474" Comment="edited title" Text="How to create a Java String from the contents of a file" ContentLicense="CC BY-SA 2.5" />
  <row Id="25526809" PostHistoryTypeId="5" PostId="326390" RevisionGUID="d86761ad-7b05-4492-989f-70dfeeaeda99" CreationDate="2012-06-13T23:52:14.127" UserId="93343" Comment="added 5 characters in body" Text="I've been using this idiom for some time now. And it seems to be the most wide-spread, at least in the sites I've visited. &#xD;&#xA;&#xD;&#xA;Does anyone have a better/different way to read a file into a string in Java?&#xD;&#xA;&#xD;&#xA;    private String readFile( String file ) throws IOException {&#xD;&#xA;        BufferedReader reader = new BufferedReader( new FileReader (file));&#xD;&#xA;        String         line = null;&#xD;&#xA;        StringBuilder  stringBuilder = new StringBuilder();&#xD;&#xA;        String         ls = System.getProperty(&quot;line.separator&quot;);&#xD;&#xA;        &#xD;&#xA;        while( ( line = reader.readLine() ) != null ) {&#xD;&#xA;            stringBuilder.append( line );&#xD;&#xA;            stringBuilder.append( ls );&#xD;&#xA;        }&#xD;&#xA;        &#xD;&#xA;        return stringBuilder.toString();&#xD;&#xA;    }" ContentLicense="CC BY-SA 3.0" />
  <row Id="49784538" PostHistoryTypeId="19" PostId="326390" RevisionGUID="29a89df3-0d1b-40af-8851-3d3d796f8ce0" CreationDate="2013-10-21T20:50:06.907" UserId="922184" Text="{&quot;Voters&quot;:[{&quot;Id&quot;:922184,&quot;DisplayName&quot;:&quot;Mysticial&quot;}]}" />
  <row Id="51244158" PostHistoryTypeId="4" PostId="326390" RevisionGUID="d71ebfab-bfc7-4ae0-8f1d-c1737b4d401c" CreationDate="2013-11-11T20:00:04.037" UserId="56285" Comment="edited tags; edited title" Text="How to create a Java String from the contents of a file?" ContentLicense="CC BY-SA 3.0" />
  <row Id="51244159" PostHistoryTypeId="6" PostId="326390" RevisionGUID="d71ebfab-bfc7-4ae0-8f1d-c1737b4d401c" CreationDate="2013-11-11T20:00:04.037" UserId="56285" Comment="edited tags; edited title" Text="&lt;java&gt;&lt;file&gt;&lt;file-io&gt;&lt;io&gt;" ContentLicense="CC BY-SA 3.0" />
  <row Id="107291413" PostHistoryTypeId="5" PostId="326390" RevisionGUID="07a761fc-5a1f-4462-8e2e-d86d28a55d0a" CreationDate="2015-12-28T20:11:57.230" UserId="453435" Comment="safer code, as per @hstoerr" Text="I've been using this idiom for some time now. And it seems to be the most wide-spread, at least in the sites I've visited. &#xD;&#xA;&#xD;&#xA;Does anyone have a better/different way to read a file into a string in Java?&#xD;&#xA;&#xD;&#xA;    private String readFile( String file ) throws IOException {&#xD;&#xA;        BufferedReader reader = new BufferedReader( new FileReader (file));&#xD;&#xA;        String         line = null;&#xD;&#xA;        StringBuilder  stringBuilder = new StringBuilder();&#xD;&#xA;        String         ls = System.getProperty(&quot;line.separator&quot;);&#xD;&#xA;        &#xD;&#xA;        try {&#xD;&#xA;            while( ( line = reader.readLine() ) != null ) {&#xD;&#xA;                stringBuilder.append( line );&#xD;&#xA;                stringBuilder.append( ls );&#xD;&#xA;            }&#xD;&#xA;        &#xD;&#xA;            return stringBuilder.toString();&#xD;&#xA;        } finally {&#xD;&#xA;            reader.close();&#xD;&#xA;        }&#xD;&#xA;    }" ContentLicense="CC BY-SA 3.0" />
  <row Id="107291414" PostHistoryTypeId="24" PostId="326390" RevisionGUID="07a761fc-5a1f-4462-8e2e-d86d28a55d0a" CreationDate="2015-12-28T20:11:57.230" Comment="Proposed by 4479896 approved by 10508, 4785185, 99027 edit id of 2258634" ContentLicense="CC BY-SA 3.0" />
  <row Id="116886433" PostHistoryTypeId="5" PostId="326390" RevisionGUID="f56b7246-49e1-4721-b9a0-d472cc266370" CreationDate="2016-04-28T21:33:58.167" UserId="63550" Comment="Copy edited." Text="I've been using the idiom below for some time now. And it seems to be the most wide-spread, at least on the sites I've visited.&#xD;&#xA;&#xD;&#xA;Is there a better/different way to read a file into a string in Java?&#xD;&#xA;&#xD;&#xA;    private String readFile(String file) throws IOException {&#xD;&#xA;        BufferedReader reader = new BufferedReader(new FileReader (file));&#xD;&#xA;        String         line = null;&#xD;&#xA;        StringBuilder  stringBuilder = new StringBuilder();&#xD;&#xA;        String         ls = System.getProperty(&quot;line.separator&quot;);&#xD;&#xA;&#xD;&#xA;        try {&#xD;&#xA;            while((line = reader.readLine()) != null) {&#xD;&#xA;                stringBuilder.append(line);&#xD;&#xA;                stringBuilder.append(ls);&#xD;&#xA;            }&#xD;&#xA;&#xD;&#xA;            return stringBuilder.toString();&#xD;&#xA;        } finally {&#xD;&#xA;            reader.close();&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
  <row Id="116886434" PostHistoryTypeId="4" PostId="326390" RevisionGUID="f56b7246-49e1-4721-b9a0-d472cc266370" CreationDate="2016-04-28T21:33:58.167" UserId="63550" Comment="Copy edited." Text="How do I create a Java string from the contents of a file?" ContentLicense="CC BY-SA 3.0" />
  <row Id="181644472" PostHistoryTypeId="6" PostId="326390" RevisionGUID="3686582a-672b-415f-b0d5-b2831e8b2f14" CreationDate="2018-09-12T17:54:58.040" UserId="1746118" Comment="edited tags" Text="&lt;java&gt;&lt;string&gt;&lt;file&gt;&lt;file-io&gt;&lt;io&gt;" ContentLicense="CC BY-SA 4.0" />
  <row Id="7872663" PostHistoryTypeId="2" PostId="3758653" RevisionGUID="a4930b1e-4be9-43cf-b9ff-a58efdc4c221" CreationDate="2010-09-21T08:49:16.057" UserId="342852" Text="I asked the same Question recently:&#xD;&#xA;&#xD;&#xA;[Format file size as MB, GB etc][1]&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;    &#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7872768" PostHistoryTypeId="5" PostId="3758653" RevisionGUID="9eb44f35-96ea-4d11-b046-862836702c86" CreationDate="2010-09-21T08:56:21.620" UserId="342852" Comment="added 325 characters in body" Text="I asked the same Question recently:&#xD;&#xA;&#xD;&#xA;[Format file size as MB, GB etc][1]&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;    &#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Test code:&#xD;&#xA;&#xD;&#xA;    public static void main(final String[] args){&#xD;&#xA;        final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l };&#xD;&#xA;        for(final long ll : l){&#xD;&#xA;            System.out.println(convertToStringRepresentation(ll));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Output:&#xD;&#xA;&#xD;&#xA;    1 B&#xD;&#xA;    4,2 KB&#xD;&#xA;    41,4 MB&#xD;&#xA;    3,3 GB&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7872867" PostHistoryTypeId="5" PostId="3758653" RevisionGUID="85454b7e-98ba-478a-aacd-8085eef0befc" CreationDate="2010-09-21T09:02:21.617" UserId="342852" Comment="added 22 characters in body" Text="I asked the same Question recently:&#xD;&#xA;&#xD;&#xA;[Format file size as MB, GB etc][1]&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;    &#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Test code:&#xD;&#xA;&#xD;&#xA;    public static void main(final String[] args){&#xD;&#xA;        final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l };&#xD;&#xA;        for(final long ll : l){&#xD;&#xA;            System.out.println(convertToStringRepresentation(ll));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Output (on my German Locale):&#xD;&#xA;&#xD;&#xA;    1 B&#xD;&#xA;    4,2 KB&#xD;&#xA;    41,4 MB&#xD;&#xA;    3,3 GB&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" ContentLicense="CC BY-SA 2.5" />
  <row Id="7873174" PostHistoryTypeId="5" PostId="3758653" RevisionGUID="6e99b8c4-40f4-4d15-a608-fdaf60bfd574" CreationDate="2010-09-21T09:23:11.483" UserId="342852" Comment="added 209 characters in body" Text="I asked the same Question recently:&#xD;&#xA;&#xD;&#xA;[Format file size as MB, GB etc][1]&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;    &#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Test code:&#xD;&#xA;&#xD;&#xA;    public static void main(final String[] args){&#xD;&#xA;        final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l };&#xD;&#xA;        for(final long ll : l){&#xD;&#xA;            System.out.println(convertToStringRepresentation(ll));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Output (on my German Locale):&#xD;&#xA;&#xD;&#xA;    1 B&#xD;&#xA;    4,2 KB&#xD;&#xA;    41,4 MB&#xD;&#xA;    3,3 GB&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Edit: I have opened an [Issue requesting this functionality for Google Guava][2]. Perhaps someone would care to support it.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: http://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;  [2]: http://code.google.com/p/guava-libraries/issues/detail?id=428" ContentLicense="CC BY-SA 2.5" />
  <row Id="147502865" PostHistoryTypeId="5" PostId="3758653" RevisionGUID="24bcc0f3-8d8d-4203-b465-6d7c2c0c4fde" CreationDate="2017-05-23T12:26:42.257" UserDisplayName="URL Rewriter Bot" Comment="replaced http://stackoverflow.com/ with https://stackoverflow.com/" Text="I asked the same Question recently:&#xD;&#xA;&#xD;&#xA;[Format file size as MB, GB etc][1]&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;    &#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;    &#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Test code:&#xD;&#xA;&#xD;&#xA;    public static void main(final String[] args){&#xD;&#xA;        final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l };&#xD;&#xA;        for(final long ll : l){&#xD;&#xA;            System.out.println(convertToStringRepresentation(ll));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Output (on my German Locale):&#xD;&#xA;&#xD;&#xA;    1 B&#xD;&#xA;    4,2 KB&#xD;&#xA;    41,4 MB&#xD;&#xA;    3,3 GB&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;Edit: I have opened an [Issue requesting this functionality for Google Guava][2]. Perhaps someone would care to support it.&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;  [2]: http://code.google.com/p/guava-libraries/issues/detail?id=428" ContentLicense="CC BY-SA 3.0" />
  <row Id="228647921" PostHistoryTypeId="5" PostId="3758653" RevisionGUID="5d37d573-eea6-4543-b875-5684c8d22354" CreationDate="2020-08-12T18:41:04.757" UserId="63550" Comment="Active reading [&lt;https://en.wiktionary.org/wiki/question#Noun&gt; &lt;https://en.wiktionary.org/wiki/locale#Noun&gt;]. " Text="I asked the same question recently:&#xD;&#xA;&#xD;&#xA;*[Format file size as MB, GB, etc.][1]*&#xD;&#xA;&#xD;&#xA;While there is no out-of-the-box answer, I can live with the solution:&#xD;&#xA;&#xD;&#xA;    private static final long K = 1024;&#xD;&#xA;    private static final long M = K * K;&#xD;&#xA;    private static final long G = M * K;&#xD;&#xA;    private static final long T = G * K;&#xD;&#xA;&#xD;&#xA;    public static String convertToStringRepresentation(final long value){&#xD;&#xA;        final long[] dividers = new long[] { T, G, M, K, 1 };&#xD;&#xA;        final String[] units = new String[] { &quot;TB&quot;, &quot;GB&quot;, &quot;MB&quot;, &quot;KB&quot;, &quot;B&quot; };&#xD;&#xA;        if(value &lt; 1)&#xD;&#xA;            throw new IllegalArgumentException(&quot;Invalid file size: &quot; + value);&#xD;&#xA;        String result = null;&#xD;&#xA;        for(int i = 0; i &lt; dividers.length; i++){&#xD;&#xA;            final long divider = dividers[i];&#xD;&#xA;            if(value &gt;= divider){&#xD;&#xA;                result = format(value, divider, units[i]);&#xD;&#xA;                break;&#xD;&#xA;            }&#xD;&#xA;        }&#xD;&#xA;        return result;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;    private static String format(final long value,&#xD;&#xA;        final long divider,&#xD;&#xA;        final String unit){&#xD;&#xA;        final double result =&#xD;&#xA;            divider &gt; 1 ? (double) value / (double) divider : (double) value;&#xD;&#xA;        return new DecimalFormat(&quot;#,##0.#&quot;).format(result) + &quot; &quot; + unit;&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;Test code:&#xD;&#xA;&#xD;&#xA;    public static void main(final String[] args){&#xD;&#xA;        final long[] l = new long[] { 1l, 4343l, 43434334l, 3563543743l };&#xD;&#xA;        for(final long ll : l){&#xD;&#xA;            System.out.println(convertToStringRepresentation(ll));&#xD;&#xA;        }&#xD;&#xA;    }&#xD;&#xA;&#xD;&#xA;Output (on my German locale):&#xD;&#xA;&#xD;&#xA;    1 B&#xD;&#xA;    4,2 KB&#xD;&#xA;    41,4 MB&#xD;&#xA;    3,3 GB&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;----------&#xD;&#xA;&#xD;&#xA;I have opened an [issue requesting this functionality for Google Guava][2]. Perhaps someone would care to support it.&#xD;&#xA;&#xD;&#xA;  [1]: https://stackoverflow.com/questions/3263892/format-file-size-as-mb-gb-etc&#xD;&#xA;  [2]: http://code.google.com/p/guava-libraries/issues/detail?id=428&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;&#xD;&#xA;" ContentLicense="CC BY-SA 4.0" />
  <row Id="10366008" PostHistoryTypeId="2" PostId="4888400" RevisionGUID="dddc9332-a054-437d-bbc5-84b9628f6b21" CreationDate="2011-02-03T15:57:16.907" UserId="601806" Text="`FileUtils.byteCountToDisplaySize(long size)` would work" ContentLicense="CC BY-SA 2.5" />
  <row Id="15944173" PostHistoryTypeId="5" PostId="4888400" RevisionGUID="3ff74694-2969-45bd-a5fb-ca9411a790ad" CreationDate="2011-08-30T14:00:17.047" UserId="32043" Comment="Added JavaDoc" Text="`FileUtils.byteCountToDisplaySize(long size)` would work&#xD;&#xA;&#xD;&#xA;[JavaDoc for this function](http://commons.apache.org/io/apidocs/org/apache/commons/io/FileUtils.html#byteCountToDisplaySize%28long%29)" ContentLicense="CC BY-SA 3.0" />
  <row Id="22540489" PostHistoryTypeId="5" PostId="4888400" RevisionGUID="78f56f7e-38cb-4ee9-bfe2-3669a4da5b6a" CreationDate="2012-03-25T06:48:18.303" UserId="110358" Comment="improve a pretty good answer" Text="`FileUtils.byteCountToDisplaySize(long size)` would work if your project can depend on `org.apache.commons.io`.&#xD;&#xA;&#xD;&#xA;[JavaDoc for this method](http://commons.apache.org/io/apidocs/org/apache/commons/io/FileUtils.html#byteCountToDisplaySize%28long%29)" ContentLicense="CC BY-SA 3.0" />
  <row Id="22540490" PostHistoryTypeId="24" PostId="4888400" RevisionGUID="78f56f7e-38cb-4ee9-bfe2-3669a4da5b6a" CreationDate="2012-03-25T06:48:18.303" Comment="Proposed by 110358 approved by 268273, 230513 edit id of 227196" ContentLicense="CC BY-SA 3.0" />
  <row Id="119874273" PostHistoryTypeId="5" PostId="4888400" RevisionGUID="288ead38-129a-42f3-8871-d64bd2baff64" CreationDate="2016-06-07T13:27:35.507" UserId="1248724" Comment="Fixed Javadoc Link" Text="`FileUtils.byteCountToDisplaySize(long size)` would work if your project can depend on `org.apache.commons.io`.&#xD;&#xA;&#xD;&#xA;[JavaDoc for this method](https://commons.apache.org/proper/commons-io/javadocs/api-2.4/org/apache/commons/io/FileUtils.html#byteCountToDisplaySize(long))" ContentLicense="CC BY-SA 3.0" />
  <row Id="119874274" PostHistoryTypeId="24" PostId="4888400" RevisionGUID="288ead38-129a-42f3-8871-d64bd2baff64" CreationDate="2016-06-07T13:27:35.507" Comment="Proposed by 1248724 approved by 5277820, 1466535, 586986 edit id of 2549530" ContentLicense="CC BY-SA 3.0" />
  <row Id="13080338" PostHistoryTypeId="2" PostId="6046761" RevisionGUID="40cf91e1-a6a8-4203-bfad-9239eaf74709" CreationDate="2011-05-18T14:53:35.757" UserId="438960" Text="&lt;pre&gt;&lt;code&gt;&#xD;&#xA;private static final String[] Q = new String[]{&quot;&quot;, &quot;K&quot;, &quot;M&quot;, &quot;G&quot;, &quot;T&quot;, &quot;P&quot;, &quot;E&quot;};&#xD;&#xA;&#xD;&#xA;public String getAsString(long bytes)&#xD;&#xA;{&#xD;&#xA; for (int i = 6; i &gt; 0; i--)&#xD;&#xA;        {&#xD;&#xA;             double step = Math.pow(1024, i);&#xD;&#xA;                if (bytes &gt; step) return String.format(&quot;%3.1f %s&quot;, bytes / step, Q[i]);&#xD;&#xA;  }&#xD;&#xA;     return Long.toString(bytes);&#xD;&#xA;}&#xD;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xD;&#xA;" ContentLicense="CC BY-SA 3.0" />
</posthistory>
